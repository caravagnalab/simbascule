data <- as.matrix(data[, 2:ncol(data), drop=FALSE])
rownames(data) <- samples_names
data <- data[sort(rownames(data)), , drop=FALSE]
data <- data[, sort(colnames(data)), drop=FALSE]
trinucleotides_counts <- array(0, c(nrow(data), 96))
rownames(trinucleotides_counts) <- rownames(data)
colnames(trinucleotides_counts) <- sort(as.character(mutation_categories$cat))
rows_contexts <- rownames(data)
cols_contexts <- colnames(trinucleotides_counts)[which(colnames(trinucleotides_counts)%in%colnames(data))]
trinucleotides_counts[rows_contexts,cols_contexts] <- data[rows_contexts,cols_contexts]
# return trinucleotides counts matrix
return(trinucleotides_counts)
}
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
head(x)
y <- as.data.frame(x)
head(y)
count.matrix <- function(data, reference = NULL) {
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference, data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
# identify trinucleotides motif
data$cat <- ifelse(as.vector(data$ref) %in% c("C","T"),paste0(subseq(data$context,1,1),"[",data$ref,">",data$alt,"]",subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1),"[",data$cref,">",data$calt,"]",subseq(data$rccontext,3,3)))
# create 96 trinucleotides mutation categories
categories_context <- NULL
categories_alt <- rep(c(rep("C>A",4),rep("C>G",4),rep("C>T",4),rep("T>A",4),rep("T>C",4),rep("T>G",4)),4)
categories_cat <- NULL
cont <- 0
for(i in c("A","C","G","T")) {
for(j in 1:6) {
for(k in c("A","C","G","T")) {
cont <- cont + 1
categories_context <- c(categories_context,paste0(k,":",i))
categories_cat <- c(categories_cat,paste0(k,"[",categories_alt[cont],"]",i))
}
}
}
mutation_categories <- data.table::data.table(context=categories_context,alt=categories_alt,cat=categories_cat)
# count number of mutations per sample for each category
input1 <- data.table::data.table(mutation_categories[,"cat"])
input2 <- data.table::data.table(sample=data$sample,cat=data$cat)
input2 <- input2[,.N,by=.(sample,cat)]
data <- merge(input1,input2,by="cat",all=TRUE)
data <- data.table::dcast(data,sample~cat,value.var="N")
data <- data[!is.na(sample),drop=FALSE]
data[is.na(data)] <- 0
# make trinucleotides counts matrix
samples_names <- data$sample
data <- as.matrix(data[, 2:ncol(data), drop=FALSE])
rownames(data) <- samples_names
data <- data[sort(rownames(data)), , drop=FALSE]
data <- data[, sort(colnames(data)), drop=FALSE]
trinucleotides_counts <- array(0, c(nrow(data), 96))
rownames(trinucleotides_counts) <- rownames(data)
colnames(trinucleotides_counts) <- sort(as.character(mutation_categories$cat))
rows_contexts <- rownames(data)
cols_contexts <- colnames(trinucleotides_counts)[which(colnames(trinucleotides_counts)%in%colnames(data))]
trinucleotides_counts[rows_contexts,cols_contexts] <- data[rows_contexts,cols_contexts]
# return trinucleotides counts matrix
df <- as.data.frame(trinucleotides_counts) # added
return(df)
}
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
head(x)
head(ssm560_reduced)
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference, data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
# identify trinucleotides motif
data$cat <- ifelse(
as.vector(data$ref) %in% c("C","T"),
paste0(subseq(data$context,1,1), "[", data$ref, ">", data$alt, "]", subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1), "[", data$cref,">", data$calt, "]", subseq(data$rccontext,3,3))
)
head(data)
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
head(data)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
head(data)
head(data)
head(data)
# find context for each mutation
data$context <- getSeq(reference, data)
head(data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
head(data)
# identify trinucleotides motif
data$cat <- ifelse(
as.vector(data$ref) %in% c("C","T"),
paste0(subseq(data$context,1,1), "[", data$ref, ">", data$alt, "]", subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1), "[", data$cref,">", data$calt, "]", subseq(data$rccontext,3,3))
)
head(data)
# create 96 trinucleotides mutation categories
categories_context <- NULL
categories_alt <- rep(c(rep("C>A",4), rep("C>G",4), rep("C>T",4), rep("T>A",4), rep("T>C",4), rep("T>G",4)), 4)
categories_cat <- NULL
cont <- 0
for(i in c("A","C","G","T")) {
for(j in 1:6) {
for(k in c("A","C","G","T")) {
cont <- cont + 1
categories_context <- c(categories_context,paste0(k,":",i))
categories_cat <- c(categories_cat,paste0(k,"[",categories_alt[cont],"]",i))
}
}
}
categories_context
categories_cat
mutation_categories <- data.table::data.table(context=categories_context,alt=categories_alt,cat=categories_cat)
mutation_categories
# count number of mutations per sample for each category
input1 <- data.table::data.table(mutation_categories[,"cat"])
input2 <- data.table::data.table(sample=data$sample,cat=data$cat)
input2 <- input2[,.N,by=.(sample,cat)]
data <- merge(input1,input2,by="cat",all=TRUE)
data <- data.table::dcast(data,sample~cat,value.var="N")
data <- data[!is.na(sample),drop=FALSE]
data[is.na(data)] <- 0
head(data)
head(ssm560_reduced)
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
head(x)
head(x)
library(basilica)
x <- count.matrix(data)
load("/home/azad/Downloads/ssm560_reduced.rda")
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
library("BSgenome.Hsapiens.1000genomes.hs37d5")
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
basilica:::.plot_signatures(x)
basilica::plot_signatures(x)
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
.plot_signatures <- function(beta, useRowNames = TRUE, xlabels = TRUE) {
# set names of the signatures
if(!useRowNames) {
rownames(beta) <- paste0("Signature ",1:nrow(beta))
}
# separate context and alteration
x <- data.table::as.data.table(reshape2::melt(as.matrix(beta),varnames=c("signature","cat")))
x[,Context:=paste0(substr(cat,1,1),".",substr(cat,7,7))]
x[,alt:=paste0(substr(cat,3,3),">",substr(cat,5,5))]
# make the ggplot2 object
glist <- list()
for(i in 1:nrow(beta)) {
plt <- ggplot(x[signature==rownames(beta)[i]]) +
geom_bar(aes(x=Context,y=value,fill=alt),stat="identity",position="identity") +
facet_wrap(~alt,nrow=1,scales="free_x") +
theme(axis.text.x=element_text(angle=90,hjust=1),panel.background=element_blank(),axis.line=element_line(colour="black")) +
ggtitle(rownames(beta)[i]) + theme(legend.position="none") + ylab("Frequency of mutations")
if(!xlabels) {
plt <- plt + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())
}
glist[[i]] <- plt
}
# make the final plot
#p <- gridExtra::grid.arrange(grobs=glist, ncol=ceiling(nrow(beta)/3)) # by sparse
p <- ggpubr::ggarrange(plotlist=glist, ncol = 1) # by me
return(p)
}
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
reference_catalogue <- read.table(ref_path, sep = ",", row.names = 1, header = TRUE, check.names = FALSE)
rownames(reference_catalogue)
SBS1 <- reference_catalogue['SBS1',]
a <- .plot_signatures(beta=SBS1, useRowNames = TRUE, xlabels = TRUE)
library(ggplot2)
a <- .plot_signatures(beta=SBS1, useRowNames = TRUE, xlabels = TRUE)
a
setwd("~/Documents/thesis/simbasilica/")  # set working directory to package directory
getwd()
devtools::load_all()                      # load the package
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
x <- simbasilica::split.reference(reference_path = ref_path, ratio = 0.7, seed = 64)
reference_catalogue <- x$reference
denovo_catalogue <- x$denovo
reference_cosine <- simbasilica:::cosine.matrix(reference_catalogue, reference_catalogue)
denovo_cosine <- simbasilica:::cosine.matrix(denovo_catalogue, denovo_catalogue)
signatures <- simbasilica::generate.signatures(
reference_catalogue = reference_catalogue,
denovo_catalogue = denovo_catalogue,
reference_cosine = reference_cosine,
denovo_cosine = denovo_cosine,
complexity = c(4,2),
similarity_limit= 0.5,
seed=64
)
beta <- rbind(signatures$fixed, signatures$denovo)
beta
x <- c(0, NULL, 0.8)
x
length(x)
beta
alpha <- generate.exposure(beta=beta, groups=rep(1,45), seed=64)
alpha
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
x <- simbasilica::split.reference(reference_path = ref_path, ratio = 0.7, seed = 94)
reference_catalogue <- x$reference
denovo_catalogue <- x$denovo
reference_cosine <- simbasilica:::cosine.matrix(reference_catalogue, reference_catalogue)
denovo_cosine <- simbasilica:::cosine.matrix(denovo_catalogue, denovo_catalogue)
signatures <- simbasilica::generate.signatures(
reference_catalogue = reference_catalogue,
denovo_catalogue = denovo_catalogue,
reference_cosine = reference_cosine,
denovo_cosine = denovo_cosine,
complexity = c(4,2),
similarity_limit= 0.5,
seed=64
)
beta <- rbind(signatures$fixed, signatures$denovo)
beta
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
signatures <- rownames(beta)
signatures <- rownames(beta)
signatures
if (!('SBS1' %in% signatures)) {
stop('Wrong signatures! SBS1 not included!')
}
if (length(signatures) < 2) {
stop("not valid! there are not enough signatures!")
}
df_list <- list()
signatures <- signatures[! signatures %in% c('SBS1')] # excludes SBS1
signatures
unique(rep(1,34))
groups
groups <- rep(1,5)
signatures
sigNums <- length(signatures)
if (length(unique(groups))==1) {
sigNums <- length(signatures)
sigNames <- c('SBS1', signatures)
} else {
sigNums <- sample(1:length(signatures), 1)
sigNames <- c('SBS1', sample(signatures, sigNums))
}
sigNums
sigNames
colnames(beta)
rownames(beta)
sigNums
sigNames
num_samples <- length(groups[groups==1])
num_samples
x <- matrix( runif(num_samples * (sigNums+1), 0, 1), ncol = sigNums+1 )
x
alpha <- x / rowSums(x)
alpha <- as.data.frame(alpha)
colnames(alpha) <- sigNames
alpha$group <- rep(group, num_samples)
alpha
alpha$group <- rep(1, num_samples)
alpha
df_list[length(df_list)+1] <- list(alpha)
df_list
rownames(beta)
data <- Reduce(function(x, y) merge(x, y, all=TRUE), df_list)
data
column_names <- colnames(data)
column_names
column_names <- column_names[order(column_names)]
column_names
# sort columns
column_names <- colnames(data)
#column_names <- column_names[order(column_names)]
column_names <- append(setdiff(column_names, "group"), "group")
data
#column_names[length(column_names)+1] <- "group"
data <- data[, column_names]
data
# sort columns
column_names <- colnames(data)
#column_names <- column_names[order(column_names)]
column_names <- append(setdiff(column_names, "group"), "group")
#column_names[length(column_names)+1] <- "group"
data <- data[, column_names]
data[is.na(data)] <- 0    # convert 'NA' to zero
data
rownames(beta)
data[order(data$group), ] # sort rows by group column
data
beta
rownames(beta)
beta
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
devtools::load_all()                      # load the package
rownames(beta)
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
alpha
alpha <- subset(alpha, select = -c(group))
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
alpha <- subset(alpha, select = -c(group))
alpha
runif(5, 0, 1)
nrow(alpha)
n <- nrow(alpha)
val <- 0.05
runif(n, 0, val)
x <- runif(n, 0, val)
x
alpha
# SBS16
alpha$SBS16 <- x
alpha
alpha[,4]
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
alpha <- subset(alpha, select = -c(group))
alpha
alpha
n <- nrow(alpha)
val <- 0.05
new <- runif(n, 0, val)
new
diffVal <- alpha[,4] - new
diffVal
alpha[,4]
new
diffVal <- alpha[,4] - new
diffVal
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha
alpha <- subset(alpha, select = -c(group))
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha <- subset(alpha, select = -c(group))
alpha
rowSums(alpha)
n <- nrow(alpha)
val <- 0.05
new <- runif(n, 0, val)
diffVal <- alpha[,4] - new
alpha[0,3] <- alpha[0,3] + diffVal
alpha
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha <- subset(alpha, select = -c(group))
alpha
rowSums(alpha)
n <- nrow(alpha)
val <- 0.05
new <- runif(n, 0, val)
diffVal <- alpha[,4] - new
alpha[,4] <- new
alpha[,3] <- alpha[0,3] + diffVal
alpha
new
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha <- subset(alpha, select = -c(group))
alpha
rowSums(alpha)
alpha
n <- nrow(alpha)
val <- 0.05
new <- runif(n, 0, val)
diffVal <- alpha[,4] - new
alpha[,4] <- new
alpha[, 3] <- alpha[,3] + diffVal
alpha
rowSums(alpha)
sum(rowSums(alpha))
if ( sum(rowSums(alpha))==n ) {
print("TRUE")
} else {
print("WRONG")
}
rowSums(alpha)
# ------------------------------------------------------------------------------
# fixed signatures exposure set
# ------------------------------------------------------------------------------
alpha
rowSums(alpha)
n <- nrow(alpha)
val <- 0.05
new <- runif(n, 0, val)
diffVal <- alpha[,6] - new
alpha[,6] <- new
diffVal
alpha[, 5] <- alpha[,5] + diffVal
alpha
rowSums(alpha)
if ( sum(rowSums(alpha))==n ) {
print("TRUE")
} else {
print("WRONG")
}
newFixed <- runif(n, 0, val)
newDenovo <- runif(n, 0, val)
newFixed
newDenovo
newFixed <- runif(n, 0, val)
newDenovo <- runif(n, 0, val)
newDenovo
newFixed
a=2
b=a
b=44
a
b
a
