class(0)
class(0:0)
0
0:0
class(1:3)
path <- "/home/azad/Documents/other/saeid/prac/Resubmit_3.csv"
x <- read.csv(path)
class(x)
x
x$
write.csv(x, "/home/azad/Documents/other/saeid/prac/Resubmit_33.csv")
x$
write.csv(x, file="/home/azad/Documents/other/saeid/prac/Resubmit_33.csv")
write.csv(x, file="/home/azad/Documents/other/saeid/prac/Resubmit_33.csv")
path <- "/home/azad/Documents/other/saeid/prac/Resubmit_3.csv"
x <- read.csv(path)
x
nrow(x)
ncol(x)
write.csv(x, file="/home/azad/Documents/other/saeid/prac/Resubmit_33.csv")
x <- read.csv(path, sep = ",")
class(x)
nrow(x)
ncol(x)
x
path2 <- "/home/azad/Downloads/ssm560_reduced.rda"
load(path2)
class(ssm560_reduced)
head(ssm560_reduced)
library("BSgenome.Hsapiens.1000genomes.hs37d5")
data <- ssm560_reduced
reference = "BSgenome.Hsapiens.1000genomes.hs37d5"
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
reference
reference = BSgenome.Hsapiens.1000genomes.hs37d5
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
head(ssm560_reduced)
class(ssm560_reduced)
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
class(data)
head(data)
nrow(data)
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
nrow(data)
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
nrow(data)
head(data)
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
head(data)
nrow(data)
data <- unique(data)
nrow(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
head(data)
# convert data to GRanges
data <- GRanges(data$chrom,IRanges(start=(data$pos-1),width=3),ref=DNAStringSet(data$ref),alt=DNAStringSet(data$alt),sample=data$sample)
class(data)
head(data)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference)))>0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference,data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context,2,2)!=data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
class(data)
head(data)
head(data)
head(data)
count.matrix <- function(data, reference = NULL) {
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference, data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
# identify trinucleotides motif
data$cat <- ifelse(as.vector(data$ref) %in% c("C","T"),paste0(subseq(data$context,1,1),"[",data$ref,">",data$alt,"]",subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1),"[",data$cref,">",data$calt,"]",subseq(data$rccontext,3,3)))
# create 96 trinucleotides mutation categories
categories_context <- NULL
categories_alt <- rep(c(rep("C>A",4),rep("C>G",4),rep("C>T",4),rep("T>A",4),rep("T>C",4),rep("T>G",4)),4)
categories_cat <- NULL
cont <- 0
for(i in c("A","C","G","T")) {
for(j in 1:6) {
for(k in c("A","C","G","T")) {
cont <- cont + 1
categories_context <- c(categories_context,paste0(k,":",i))
categories_cat <- c(categories_cat,paste0(k,"[",categories_alt[cont],"]",i))
}
}
}
mutation_categories <- data.table::data.table(context=categories_context,alt=categories_alt,cat=categories_cat)
# count number of mutations per sample for each category
input1 <- data.table::data.table(mutation_categories[,"cat"])
input2 <- data.table::data.table(sample=data$sample,cat=data$cat)
input2 <- input2[,.N,by=.(sample,cat)]
data <- merge(input1,input2,by="cat",all=TRUE)
data <- data.table::dcast(data,sample~cat,value.var="N")
data <- data[!is.na(sample),drop=FALSE]
data[is.na(data)] <- 0
# make trinucleotides counts matrix
samples_names <- data$sample
data <- as.matrix(data[, 2:ncol(data), drop=FALSE])
rownames(data) <- samples_names
data <- data[sort(rownames(data)), , drop=FALSE]
data <- data[, sort(colnames(data)), drop=FALSE]
trinucleotides_counts <- array(0, c(nrow(data), 96))
rownames(trinucleotides_counts) <- rownames(data)
colnames(trinucleotides_counts) <- sort(as.character(mutation_categories$cat))
rows_contexts <- rownames(data)
cols_contexts <- colnames(trinucleotides_counts)[which(colnames(trinucleotides_counts)%in%colnames(data))]
trinucleotides_counts[rows_contexts,cols_contexts] <- data[rows_contexts,cols_contexts]
# return trinucleotides counts matrix
return(trinucleotides_counts)
}
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
head(x)
y <- as.data.frame(x)
head(y)
count.matrix <- function(data, reference = NULL) {
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference, data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
# identify trinucleotides motif
data$cat <- ifelse(as.vector(data$ref) %in% c("C","T"),paste0(subseq(data$context,1,1),"[",data$ref,">",data$alt,"]",subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1),"[",data$cref,">",data$calt,"]",subseq(data$rccontext,3,3)))
# create 96 trinucleotides mutation categories
categories_context <- NULL
categories_alt <- rep(c(rep("C>A",4),rep("C>G",4),rep("C>T",4),rep("T>A",4),rep("T>C",4),rep("T>G",4)),4)
categories_cat <- NULL
cont <- 0
for(i in c("A","C","G","T")) {
for(j in 1:6) {
for(k in c("A","C","G","T")) {
cont <- cont + 1
categories_context <- c(categories_context,paste0(k,":",i))
categories_cat <- c(categories_cat,paste0(k,"[",categories_alt[cont],"]",i))
}
}
}
mutation_categories <- data.table::data.table(context=categories_context,alt=categories_alt,cat=categories_cat)
# count number of mutations per sample for each category
input1 <- data.table::data.table(mutation_categories[,"cat"])
input2 <- data.table::data.table(sample=data$sample,cat=data$cat)
input2 <- input2[,.N,by=.(sample,cat)]
data <- merge(input1,input2,by="cat",all=TRUE)
data <- data.table::dcast(data,sample~cat,value.var="N")
data <- data[!is.na(sample),drop=FALSE]
data[is.na(data)] <- 0
# make trinucleotides counts matrix
samples_names <- data$sample
data <- as.matrix(data[, 2:ncol(data), drop=FALSE])
rownames(data) <- samples_names
data <- data[sort(rownames(data)), , drop=FALSE]
data <- data[, sort(colnames(data)), drop=FALSE]
trinucleotides_counts <- array(0, c(nrow(data), 96))
rownames(trinucleotides_counts) <- rownames(data)
colnames(trinucleotides_counts) <- sort(as.character(mutation_categories$cat))
rows_contexts <- rownames(data)
cols_contexts <- colnames(trinucleotides_counts)[which(colnames(trinucleotides_counts)%in%colnames(data))]
trinucleotides_counts[rows_contexts,cols_contexts] <- data[rows_contexts,cols_contexts]
# return trinucleotides counts matrix
df <- as.data.frame(trinucleotides_counts) # added
return(df)
}
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
head(x)
head(ssm560_reduced)
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
# find context for each mutation
data$context <- getSeq(reference, data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
# identify trinucleotides motif
data$cat <- ifelse(
as.vector(data$ref) %in% c("C","T"),
paste0(subseq(data$context,1,1), "[", data$ref, ">", data$alt, "]", subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1), "[", data$cref,">", data$calt, "]", subseq(data$rccontext,3,3))
)
head(data)
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
# check that reference is a BSgenome object
if (is.null(reference) | class(reference)!="BSgenome") {
stop("The reference genome provided as input needs to be a BSgenome object.")
}
# preprocessing input data
data <- as.data.frame(data)
colnames(data) <- c("sample","chrom","start","end","ref","alt")
# consider only single nucleotide variants involving (A,C,G,T) bases
data <- data[which(data[,"start"]==data[,"end"]),,drop=FALSE]
data <- data[which(as.matrix(data[,"ref"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[which(as.matrix(data[,"alt"])%in%c("A","C","G","T")),,drop=FALSE]
data <- data[,c("sample","chrom","start","ref","alt"),drop=FALSE]
colnames(data) <- c("sample","chrom","pos","ref","alt")
data <- unique(data)
data <- data[order(data[,"sample"],data[,"chrom"],data[,"pos"]),,drop=FALSE]
# convert data to GRanges
data <- GRanges(
data$chrom,
IRanges(start=(data$pos-1), width=3),
ref=DNAStringSet(data$ref),
alt=DNAStringSet(data$alt),
sample=data$sample
)
head(data)
# check that all chromosomes match reference
if (length(setdiff(seqnames(data),GenomeInfoDb::seqnames(reference))) > 0) {
warning("Check chromosome names, not all match reference genome.")
}
head(data)
head(data)
head(data)
# find context for each mutation
data$context <- getSeq(reference, data)
head(data)
# check for any mismatch with BSgenome context
if (any(subseq(data$context, 2, 2) != data$ref)) {
warning("Check reference bases, not all match context.")
}
# get complements and reverse complements
data$cref <- complement(data$ref)
data$calt <- complement(data$alt)
data$rccontext <- reverseComplement(data$context)
head(data)
# identify trinucleotides motif
data$cat <- ifelse(
as.vector(data$ref) %in% c("C","T"),
paste0(subseq(data$context,1,1), "[", data$ref, ">", data$alt, "]", subseq(data$context,3,3)),
paste0(subseq(data$rccontext,1,1), "[", data$cref,">", data$calt, "]", subseq(data$rccontext,3,3))
)
head(data)
# create 96 trinucleotides mutation categories
categories_context <- NULL
categories_alt <- rep(c(rep("C>A",4), rep("C>G",4), rep("C>T",4), rep("T>A",4), rep("T>C",4), rep("T>G",4)), 4)
categories_cat <- NULL
cont <- 0
for(i in c("A","C","G","T")) {
for(j in 1:6) {
for(k in c("A","C","G","T")) {
cont <- cont + 1
categories_context <- c(categories_context,paste0(k,":",i))
categories_cat <- c(categories_cat,paste0(k,"[",categories_alt[cont],"]",i))
}
}
}
categories_context
categories_cat
mutation_categories <- data.table::data.table(context=categories_context,alt=categories_alt,cat=categories_cat)
mutation_categories
# count number of mutations per sample for each category
input1 <- data.table::data.table(mutation_categories[,"cat"])
input2 <- data.table::data.table(sample=data$sample,cat=data$cat)
input2 <- input2[,.N,by=.(sample,cat)]
data <- merge(input1,input2,by="cat",all=TRUE)
data <- data.table::dcast(data,sample~cat,value.var="N")
data <- data[!is.na(sample),drop=FALSE]
data[is.na(data)] <- 0
head(data)
head(ssm560_reduced)
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
head(x)
head(x)
library(basilica)
x <- count.matrix(data)
load("/home/azad/Downloads/ssm560_reduced.rda")
data <- ssm560_reduced
reference=BSgenome.Hsapiens.1000genomes.hs37d5
library("BSgenome.Hsapiens.1000genomes.hs37d5")
x = count.matrix(data=ssm560_reduced, reference=BSgenome.Hsapiens.1000genomes.hs37d5)
class(x)
basilica:::.plot_signatures(x)
basilica::plot_signatures(x)
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
.plot_signatures <- function(beta, useRowNames = TRUE, xlabels = TRUE) {
# set names of the signatures
if(!useRowNames) {
rownames(beta) <- paste0("Signature ",1:nrow(beta))
}
# separate context and alteration
x <- data.table::as.data.table(reshape2::melt(as.matrix(beta),varnames=c("signature","cat")))
x[,Context:=paste0(substr(cat,1,1),".",substr(cat,7,7))]
x[,alt:=paste0(substr(cat,3,3),">",substr(cat,5,5))]
# make the ggplot2 object
glist <- list()
for(i in 1:nrow(beta)) {
plt <- ggplot(x[signature==rownames(beta)[i]]) +
geom_bar(aes(x=Context,y=value,fill=alt),stat="identity",position="identity") +
facet_wrap(~alt,nrow=1,scales="free_x") +
theme(axis.text.x=element_text(angle=90,hjust=1),panel.background=element_blank(),axis.line=element_line(colour="black")) +
ggtitle(rownames(beta)[i]) + theme(legend.position="none") + ylab("Frequency of mutations")
if(!xlabels) {
plt <- plt + theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())
}
glist[[i]] <- plt
}
# make the final plot
#p <- gridExtra::grid.arrange(grobs=glist, ncol=ceiling(nrow(beta)/3)) # by sparse
p <- ggpubr::ggarrange(plotlist=glist, ncol = 1) # by me
return(p)
}
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
reference_catalogue <- read.table(ref_path, sep = ",", row.names = 1, header = TRUE, check.names = FALSE)
rownames(reference_catalogue)
SBS1 <- reference_catalogue['SBS1',]
a <- .plot_signatures(beta=SBS1, useRowNames = TRUE, xlabels = TRUE)
library(ggplot2)
a <- .plot_signatures(beta=SBS1, useRowNames = TRUE, xlabels = TRUE)
a
setwd("~/Documents/thesis/simbasilica/")  # set working directory to package directory
devtools::load_all()                      # load the package
ref_path <- "/home/azad/Documents/thesis/pybasilica/pybasilica/data/cosmic/cosmic_catalogue.csv"
x <- simbasilica::split.reference(reference_path = ref_path, ratio = 0.7, seed = 94)
reference_catalogue <- x$reference
denovo_catalogue <- x$denovo
reference_cosine <- simbasilica:::cosine.matrix(reference_catalogue, reference_catalogue)
denovo_cosine <- simbasilica:::cosine.matrix(denovo_catalogue, denovo_catalogue)
signatures <- simbasilica::generate.signatures(
reference_catalogue = reference_catalogue,
denovo_catalogue = denovo_catalogue,
reference_cosine = reference_cosine,
denovo_cosine = denovo_cosine,
complexity = c(4,2),
similarity_limit= 0.5,
seed=128
)
beta <- rbind(signatures$fixed, signatures$denovo)
rownames(beta)
alpha <- generate.exposure(beta=beta, groups=rep(1,5), seed=64)
alpha <- subset(alpha, select = -c(group))
alpha
# ------------------------------------------------------------------------------
# edit exposure
# ------------------------------------------------------------------------------
edit.exposure(alpha) {
# ------------------------------------------------------------------------------
# edit exposure
# ------------------------------------------------------------------------------
edit.exposure <- function(alpha) {
n <- nrow(alpha)
val <- 0.05
while ( TRUE ) {
exp <- alpha
# fixed
newFixed <- runif(n, 0, val)
fixed_diff <- exp[, 4] - newFixed
exp[, 4] <- newFixed
exp[, 3] <- exp[, 3] + fixed_diff
# de-novo
newDenovo <- runif(n, 0, val)
denovo_diff <- exp[, 6] - newDenovo
exp[, 6] <- newDenovo
exp[, 5] <- exp[, 5] + denovo_diff
if ( sum(rowSums(exp))==n ) {
return(alpha)
}
}
}
alpha
x <- edit.exposure(alpha = alpha)
x
# ------------------------------------------------------------------------------
# edit exposure
# ------------------------------------------------------------------------------
edit.exposure <- function(alpha) {
n <- nrow(alpha)
val <- 0.05
while ( TRUE ) {
exp <- alpha
# fixed
newFixed <- runif(n, 0, val)
fixed_diff <- exp[, 4] - newFixed
exp[, 4] <- newFixed
exp[, 3] <- exp[, 3] + fixed_diff
# de-novo
newDenovo <- runif(n, 0, val)
denovo_diff <- exp[, 6] - newDenovo
exp[, 6] <- newDenovo
exp[, 5] <- exp[, 5] + denovo_diff
if ( sum(rowSums(exp))==n ) {
return(exp)
}
}
}
alpha
x <- edit.exposure(alpha = alpha)
x
getwd()
devtools::load_all()                      # load the package
rm(list = c("edit.exposure"))
devtools::load_all()                      # load the package
